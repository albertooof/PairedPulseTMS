ggplot2::ggtitle("CS + TS")
p3 <- ggplot2::ggplot(TS_alone_and_CS_TS,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::theme_bw()+
ggplot2::geom_line(ggplot2::aes(group = ID, col = ID), linewidth  = 0.1, alpha =0.4)+
ggplot2::geom_errorbar(data = TS_alone_and_CS_TS_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = TS_alone_and_CS_TS_mean, col = col_dots, size = 4)+
ggplot2::geom_line(data = TS_alone_and_CS_TS_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::theme(axis.title.y=ggplot2::element_blank())+
ggplot2::ggtitle("CS + TS")
return(list(plot1 = p1, plot2 = p2, plot3 = p3))
}
plots <- plot_data_for_Dataframes(data, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
plots$plot3
plots$plot2
p1 <- ggplot2::ggplot(TS_alone,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::geom_line(ggplot2::aes(group = ID , col = ID), linewidth  = 0.2, alpha = 0.4)+
ggplot2::geom_line(data = TS_alone_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::geom_errorbar(data = TS_alone_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = TS_alone_mean, col = col_dots, size = 4)+
ggplot2::theme_bw()+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::ggtitle("TS Alone")
#' @examples
#' # Basic usage
#' ID <- LETTERS[1:5]
#' dataframe_wide <- data.frame(ID = ID, matrix(stats::rnorm(5 * 16, mean = 1, sd = 0.5), nrow = 5, ncol = 16) )
#' data <- NORMALISE_PP_to_SP_forDataframe(data = dataframe_wide, format = "Wide", number_of_triggers = 16 , normalise = 5)
#' plots <- plot_data_for_Dataframes(data, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
#' plot1 <- plots$plot1
#' plot1 + ggplot2::geom_hline(yintercept = 1, col = "red")
#' plots$plot2
#' plots$plot3
plot_data_for_Dataframes <- function(data,
format = "Wide",
col_line = "grey",
col_dots = "grey",
error_measure = "se"
){
# Make sure data is a data.frame
data <- as.data.frame(data)
# if format == "Long" , we need to save ID
if (format == "Long"){
data <- as.data.frame( t (data))
}
colnames(data)[1] <- "ID"
ID <- data$ID
#data <- subset(data, select=-ID)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# filter whether it is Skill or average RT data
TS_alone <- dplyr::select(data, starts_with("TS"))
TS_alone <- cbind(ID , TS_alone)
CS_TS <- dplyr::select(data, !starts_with("TS"))
CS_TS <- cbind(ID , CS_TS)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# pivot_longer
TS_alone <- tidyr::pivot_longer(TS_alone,
cols=-ID,
names_to='var',
values_to='value')
TS_alone$time <- substr(TS_alone$var, nchar(TS_alone$var), nchar(TS_alone$var))
CS_TS <- tidyr::pivot_longer(CS_TS,
cols=-ID,
names_to='var',
values_to='value')
CS_TS$time <- substr(CS_TS$var, nchar(CS_TS$var), nchar(CS_TS$var))
TS_alone_and_CS_TS <- tidyr::pivot_longer(data,
cols=-ID,
names_to='var',
values_to='value')
TS_alone_and_CS_TS$time <- substr(TS_alone_and_CS_TS$var, nchar(TS_alone_and_CS_TS$var), nchar(TS_alone_and_CS_TS$var))
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# order the x-axis variables as factors
TS_alone$time <- as.numeric(TS_alone$time)
CS_TS$time <- as.numeric(CS_TS$time)
TS_alone_and_CS_TS$time <- as.numeric(TS_alone_and_CS_TS$time)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
TS_alone$value <- as.numeric(TS_alone$value)
CS_TS$value <- as.numeric(CS_TS$value)
TS_alone$ID <- as.character(TS_alone$ID)
CS_TS$ID <- as.character(CS_TS$ID)
TS_alone_and_CS_TS$value <- as.numeric(TS_alone_and_CS_TS$value)
TS_alone_and_CS_TS$value <- as.numeric(TS_alone_and_CS_TS$value)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
TS_alone$group <- "A"
CS_TS$group <- "A"
TS_alone_and_CS_TS$group <- "A"
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# use the summary function to find mean and se/sd
TS_alone_mean <- Rmisc::summarySE(TS_alone, measurevar = "value", groupvars = "var", na.rm=T)
TS_alone_mean$group <- "A"
CS_TS_mean <-  Rmisc::summarySE(CS_TS, measurevar = "value", groupvars = "var", na.rm=T)
CS_TS_mean$group <- "A"
TS_alone_and_CS_TS_mean <-  Rmisc::summarySE(TS_alone_and_CS_TS, measurevar = "value", groupvars = "var", na.rm=T)
TS_alone_and_CS_TS_mean$group <- "A"
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# need to set the right order for the x-axis variables
TS_alone_and_CS_TS_mean <- TS_alone_and_CS_TS_mean  |>
dplyr::mutate(
num = as.numeric(stringr::str_extract(var, "\\d+$")),
is_ts_alone = stringr::str_detect(var, "^TS_alone")
)  |>
dplyr::arrange(num, dplyr::desc(is_ts_alone))  |>
dplyr::mutate(var = factor(var, levels = unique(var)))  |>
dplyr::select(-num, -is_ts_alone)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
p1 <- ggplot2::ggplot(TS_alone,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::geom_line(ggplot2::aes(group = ID , col = ID), linewidth  = 0.2, alpha = 0.4)+
ggplot2::geom_line(data = TS_alone_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::geom_errorbar(data = TS_alone_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = TS_alone_mean, col = col_dots, size = 4)+
ggplot2::theme_bw()+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::ggtitle("TS Alone")
p2 <- ggplot2::ggplot(CS_TS,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::theme_bw()+
ggplot2::geom_line(ggplot2::aes(group = ID, col = ID), linewidth  = 0.1, alpha =0.4)+
ggplot2::geom_line(data = CS_TS_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::geom_errorbar(data = CS_TS_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = CS_TS_mean, col = col_dots, size = 4)+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::theme(axis.title.y=ggplot2::element_blank())+
ggplot2::ggtitle("CS + TS")
p3 <- ggplot2::ggplot(TS_alone_and_CS_TS,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::theme_bw()+
ggplot2::geom_line(ggplot2::aes(group = ID, col = ID), linewidth  = 0.1, alpha =0.4)+
ggplot2::geom_errorbar(data = TS_alone_and_CS_TS_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = TS_alone_and_CS_TS_mean, col = col_dots, size = 4)+
ggplot2::geom_line(data = TS_alone_and_CS_TS_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::theme(axis.title.y=ggplot2::element_blank())+
ggplot2::ggtitle("CS + TS")
return(list(plot1 = p1, plot2 = p2, plot3 = p3))
}
plots <- plot_data_for_Dataframes(data, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
plot1 <- plots$plot1
plot1 + ggplot2::geom_hline(yintercept = 1, col = "red")
plots$plot2
plots$plot3
#' @examples
#' # Basic usage
#' ID <- LETTERS[1:5]
#' dataframe_wide <- data.frame(ID = ID, matrix(stats::rnorm(5 * 16, mean = 1, sd = 0.5), nrow = 5, ncol = 16) )
#' data <- NORMALISE_PP_to_SP_forDataframe(data = dataframe_wide, format = "Wide", number_of_triggers = 16 , normalise = 5)
#' plots <- plot_data_for_Dataframes(data, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
#' plot1 <- plots$plot1
#' plot1 + ggplot2::geom_hline(yintercept = 1, col = "red")
#' plots$plot2
#' plots$plot3
plot_data_for_Dataframes <- function(data,
format = "Wide",
col_line = "grey",
col_dots = "grey",
error_measure = "se"
){
# Make sure data is a data.frame
data <- as.data.frame(data)
# if format == "Long" , we need to save ID
if (format == "Long"){
data <- as.data.frame( t (data))
}
colnames(data)[1] <- "ID"
ID <- data$ID
#data <- subset(data, select=-ID)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# filter whether it is Skill or average RT data
TS_alone <- dplyr::select(data, starts_with("TS"))
TS_alone <- cbind(ID , TS_alone)
CS_TS <- dplyr::select(data, !starts_with("TS"))
CS_TS <- cbind(ID , CS_TS)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# pivot_longer
TS_alone <- tidyr::pivot_longer(TS_alone,
cols=-ID,
names_to='var',
values_to='value')
TS_alone$time <- substr(TS_alone$var, nchar(TS_alone$var), nchar(TS_alone$var))
CS_TS <- tidyr::pivot_longer(CS_TS,
cols=-ID,
names_to='var',
values_to='value')
CS_TS$time <- substr(CS_TS$var, nchar(CS_TS$var), nchar(CS_TS$var))
TS_alone_and_CS_TS <- tidyr::pivot_longer(data,
cols=-ID,
names_to='var',
values_to='value')
TS_alone_and_CS_TS$time <- substr(TS_alone_and_CS_TS$var, nchar(TS_alone_and_CS_TS$var), nchar(TS_alone_and_CS_TS$var))
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# order the x-axis variables as factors
TS_alone$time <- as.numeric(TS_alone$time)
CS_TS$time <- as.numeric(CS_TS$time)
TS_alone_and_CS_TS$time <- as.numeric(TS_alone_and_CS_TS$time)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
TS_alone$value <- as.numeric(TS_alone$value)
CS_TS$value <- as.numeric(CS_TS$value)
TS_alone$ID <- as.character(TS_alone$ID)
CS_TS$ID <- as.character(CS_TS$ID)
TS_alone_and_CS_TS$value <- as.numeric(TS_alone_and_CS_TS$value)
TS_alone_and_CS_TS$value <- as.numeric(TS_alone_and_CS_TS$value)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
TS_alone$group <- "A"
CS_TS$group <- "A"
TS_alone_and_CS_TS$group <- "A"
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# use the summary function to find mean and se/sd
TS_alone_mean <- Rmisc::summarySE(TS_alone, measurevar = "value", groupvars = "var", na.rm=T)
TS_alone_mean$group <- "A"
CS_TS_mean <-  Rmisc::summarySE(CS_TS, measurevar = "value", groupvars = "var", na.rm=T)
CS_TS_mean$group <- "A"
TS_alone_and_CS_TS_mean <-  Rmisc::summarySE(TS_alone_and_CS_TS, measurevar = "value", groupvars = "var", na.rm=T)
TS_alone_and_CS_TS_mean$group <- "A"
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
# need to set the right order for the x-axis variables
TS_alone_and_CS_TS_mean <- TS_alone_and_CS_TS_mean  |>
dplyr::mutate(
num = as.numeric(stringr::str_extract(var, "\\d+$")),
is_ts_alone = stringr::str_detect(var, "^TS_alone")
)  |>
dplyr::arrange(num, dplyr::desc(is_ts_alone))  |>
dplyr::mutate(var = factor(var, levels = unique(var)))  |>
dplyr::select(-num, -is_ts_alone)
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
p1 <- ggplot2::ggplot(TS_alone,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::geom_line(ggplot2::aes(group = ID , col = ID), linewidth  = 0.2, alpha = 0.4)+
ggplot2::geom_line(data = TS_alone_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::geom_errorbar(data = TS_alone_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = TS_alone_mean, col = col_dots, size = 4)+
ggplot2::theme_bw()+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::ggtitle("TS Alone")
p2 <- ggplot2::ggplot(CS_TS,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::theme_bw()+
ggplot2::geom_line(ggplot2::aes(group = ID, col = ID), linewidth  = 0.1, alpha =0.4)+
ggplot2::geom_line(data = CS_TS_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::geom_errorbar(data = CS_TS_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = CS_TS_mean, col = col_dots, size = 4)+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::theme(axis.title.y=ggplot2::element_blank())+
ggplot2::ggtitle("CS + TS")
p3 <- ggplot2::ggplot(TS_alone_and_CS_TS,
ggplot2::aes(var, value))+
ggplot2::geom_point(ggplot2::aes(col = ID), size = 0.5)+
ggplot2::theme_bw()+
ggplot2::geom_line(ggplot2::aes(group = ID, col = ID), linewidth  = 0.1, alpha =0.4)+
ggplot2::geom_errorbar(data = TS_alone_and_CS_TS_mean,
ggplot2::aes(x = var, ymin = value - get(error_measure), ymax = value + get(error_measure)), linewidth = 2 , width = .1, colour = col_line) +
ggplot2::geom_point(data = TS_alone_and_CS_TS_mean, col = col_dots, size = 4)+
ggplot2::geom_line(data = TS_alone_and_CS_TS_mean, ggplot2::aes(group = group ) , col = col_dots, linewidth  = 1, alpha = 1)+
ggplot2::theme(legend.position = "none")+
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 30, hjust = 1))+
ggplot2::theme(axis.title.x=ggplot2::element_blank())+
ggplot2::theme(axis.title.y=ggplot2::element_blank())+
ggplot2::ggtitle("TS Alone & CS + TS")
return(list(plot1 = p1, plot2 = p2, plot3 = p3))
}
plots <- plot_data_for_Dataframes(data, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
plots$plot3
daat
data
data_wide <- data[1, ]
data_wide
plots <- plot_data_for_Dataframes(data, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
plots$plot3
plots <- plot_data_for_Dataframes(data_wide, format = "Wide", col_line = "grey", col_dots = "grey", error_measure = "se")
plots$plot3
getwd()
setwd("C:/Users/Dell/Dropbox/F I L E S/CV/DataScienceProjects/PairedPulseTMS")
getwd()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
getwd()
knitr::opts_chunk$set(echo = TRUE , warning = FALSE, message = FALSE , fig.width = 10, fig.height = 7)
# LOAD & INSTALL PACKAGES
library(dplyr)
library(readxl)
library(ggplot2)
library(stats)
library(ggpubr)
library(writexl)
library(zoo)
library(Hmisc)
library(tidyr)
library(Rmisc)
library(RColorBrewer)
library(stringr)
library(rstatix)
library(ggpmisc)
library(lsmeans)
library(emmeans)
library(plotly)
library(MASS)
library(cocor)
library(caret)
library(e1071)
library(rmcorr)
library(lme4)
library(kernlab)
library(ggforce)
library(exactRankTests)
library(corrplot)
library(corrr)
#library(patchwork)
# library(gridExtra)
library(reshape2)
library(htmltools)
library(gridExtra)
library(car)
library(performance)
# library(glmnet)
library(summarytools)
library(knitr)
library(psych)
# install.packages("ggeffects")
#+++++++++++++++++++++++++
# LOAD FILE
directory <- "Dell"  # / Dell / albertof /
#+++++++++++++++++++++++++
## options(contrasts = c("contr.sum","contr.poly") )
# In regression and ANOVA models (including mixed models), categorical variables (a.k.a. factors) are internally turned into numbers — a process called contrast coding. This is necessary because R needs to work with numeric predictors. Different contrast schemes influence how R interprets and tests your categorical predictors, especially when interactions are involved.
#+++++++++++++++++++++++++
df_w <- read_xlsx(paste0( "C:/Users/",directory,"/Dropbox/F I L E S/tesi_ema/v_final.xlsx") )
df_w <- dplyr::mutate(df_w, across(everything(), as.character))
df_l <- pivot_longer(df_w,
cols= 36 : 53, # T0_pH : T2_Urea_mg_dl
names_to='names',
values_to='values')
# df_long <- drop_na(df_long)
#
#+++++++++++++++++++++++++
# here i group variables by time and add a new coloumn with the specifications
df_l$time <- NA
df_l$time_num <- NA
for (i in 1:nrow(df_l)){
if (startsWith ( df_l$names[i], "T0") ){
df_l$time[i] <- "T0"
df_l$time_num[i] <- 0
df_l$names[i] <- str_replace(df_l$names[i], "T0_","")
}
else if (startsWith ( df_l$names[i], "T1") ){
df_l$time[i] <- "T1"
df_l$time_num[i] <- 1
df_l$names[i] <- str_replace(df_l$names[i], "T1_","")
}
else if (startsWith ( df_l$names[i], "T2") ){
df_l$time[i] <- "T2"
df_l$time_num[i] <- 2
df_l$names[i] <- str_replace(df_l$names[i], "T2_","")
}
}
getwd()
devtools::document
devtools::document()
# Function to move on a sphere surface
move_on_sphere <- function(p, radius, d_right, d_front) {
# Normalize helper
normalize <- function(v) v / sqrt(sum(v^2))
# Unit normal at starting point
p_hat <- p / radius
# --- Step 1: move to the right ---
ex <- c(1, 0, 0)
# project ex onto tangent plane
u_right <- ex - sum(ex * p_hat) * p_hat
u_right <- normalize(u_right)
theta1 <- d_right / radius
p1_hat <- cos(theta1) * p_hat + sin(theta1) * u_right
# --- Step 2: move to the front ---
ey <- c(0, 1, 0)
u_front <- ey - sum(ey * p1_hat) * p1_hat
u_front <- normalize(u_front)
theta2 <- d_front / radius
p2_hat <- cos(theta2) * p1_hat + sin(theta2) * u_front
# final point on sphere
return(radius * p2_hat)
}
x <- as.numeric(readline("Enter X coordinate: "))
x <- as.numeric(readline("Enter X coordinate: "))
y <- as.numeric(readline("Enter Y coordinate: "))
z <- as.numeric(readline("Enter Z coordinate: "))
radius <- as.numeric(readline("Enter sphere radius: "))
d_right <- as.numeric(readline("Distance to walk to the right: "))
d_front <- as.numeric(readline("Distance to walk to the front: "))
start_point <- c(x, y, z)
final_point <- move_on_sphere(start_point, radius, d_right, d_front)
cat("Final coordinates:\n")
cat("X =", final_point[1], "\n")
cat("Y =", final_point[2], "\n")
cat("Z =", final_point[3], "\n")
# Function to normalize a vector
normalize <- function(v) {
v / sqrt(sum(v^2))
}
# Function to calculate new position on sphere
walk_on_sphere <- function(x, y, z, radius, dx, dy) {
# Current position vector
pos <- c(x, y, z)
# Normalize to exact radius (in case of rounding errors)
current_radius <- sqrt(sum(pos^2))
pos <- pos * (radius / current_radius)
cat("\nNormalized starting position:", sprintf("(%.4f, %.4f, %.4f)", pos[1], pos[2], pos[3]))
cat("\nActual radius:", sprintf("%.4f\n", sqrt(sum(pos^2))))
# Create local tangent coordinate system
# Right direction (X-axis projected onto tangent plane)
x_axis <- c(1, 0, 0)
right <- x_axis - sum(x_axis * pos) / sum(pos^2) * pos
right <- normalize(right)
# Front direction (Y-axis projected onto tangent plane)
y_axis <- c(0, 1, 0)
front <- y_axis - sum(y_axis * pos) / sum(pos^2) * pos
front <- normalize(front)
# Desired movement in tangent plane
movement <- dx * right + dy * front
# Angular distance to travel
distance <- sqrt(dx^2 + dy^2)
angle <- distance / radius
cat("\nMovement distance:", sprintf("%.4f units", distance))
cat("\nAngular distance:", sprintf("%.6f radians (%.2f degrees)\n", angle, angle * 180 / pi))
# Direction of movement (normalized)
if (distance > 0) {
direction <- normalize(movement)
# Axis of rotation (perpendicular to both pos and direction)
axis <- normalize(c(
pos[2] * direction[3] - pos[3] * direction[2],
pos[3] * direction[1] - pos[1] * direction[3],
pos[1] * direction[2] - pos[2] * direction[1]
))
# Rodrigues' rotation formula
# new_pos = pos*cos(angle) + (axis × pos)*sin(angle) + axis*(axis·pos)*(1-cos(angle))
cos_angle <- cos(angle)
sin_angle <- sin(angle)
# Cross product: axis × pos
cross <- c(
axis[2] * pos[3] - axis[3] * pos[2],
axis[3] * pos[1] - axis[1] * pos[3],
axis[1] * pos[2] - axis[2] * pos[1]
)
# Dot product: axis · pos
dot <- sum(axis * pos)
new_pos <- pos * cos_angle + cross * sin_angle + axis * dot * (1 - cos_angle)
} else {
new_pos <- pos
}
return(new_pos)
}
# Main program
cat("=== Sphere Walking Calculator ===\n\n")
# Get user input
cat("Enter your current position on the sphere:\n")
x <- as.numeric(readline("X coordinate: "))
y <- as.numeric(readline("Y coordinate: "))
z <- as.numeric(readline("Z coordinate: "))
radius <- as.numeric(readline("\nSphere radius: "))
dx <- as.numeric(readline("Distance to the RIGHT (positive) or LEFT (negative): "))
dy <- as.numeric(readline("Distance to the FRONT (positive) or BACK (negative): "))
# Calculate new position
new_pos <- walk_on_sphere(x, y, z, radius, dx, dy)
# Display results
cat("\n" , rep("=", 50), "\n", sep="")
cat("RESULTS\n")
cat(rep("=", 50), "\n", sep="")
cat(sprintf("\nNew X coordinate: %.4f", new_pos[1]))
cat(sprintf("\nNew Y coordinate: %.4f", new_pos[2]))
cat(sprintf("\nNew Z coordinate: %.4f", new_pos[3]))
# Verify the result
final_radius <- sqrt(sum(new_pos^2))
cat(sprintf("\n\nVerification - Final radius: %.4f", final_radius))
cat(sprintf("\nRadius error: %.6f\n", abs(final_radius - radius)))
# Show displacement in each axis
cat("\n" , rep("=", 50), "\n", sep="")
cat("Change in coordinates:\n")
cat(sprintf("ΔX: %+.4f\n", new_pos[1] - x))
cat(sprintf("ΔY: %+.4f\n", new_pos[2] - y))
cat(sprintf("ΔZ: %+.4f\n", new_pos[3] - z))
